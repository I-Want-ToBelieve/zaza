{
  "add_workspace_folder": {
    "annotations": [],
    "signature": "add_workspace_folder({workspace_folder})",
    "parameters": [["", "workspace_folder"]],
    "parameters_doc": {},
    "doc": [
      "Add the folder at path to the workspace folders. If {path} is not\nprovided, the user will be prompted for a path using |input()|."
    ],
    "return": [],
    "seealso": []
  },
  "apply_text_document_edit": {
    "annotations": [],
    "signature": "apply_text_document_edit({text_document_edit}, {index}, {offset_encoding})",
    "parameters": [
      ["", "text_document_edit"],
      ["", "index"],
      ["", "offset_encoding"]
    ],
    "parameters_doc": {
      "text_document_edit": "table: a `TextDocumentEdit` object",
      "index": "number: Optional index of the edit, if from a\n                          list of edits (or nil, if not from a list)"
    },
    "doc": [
      "Applies a `TextDocumentEdit`, which is a list of changes to a single\ndocument."
    ],
    "return": [],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentEdit"
    ]
  },
  "apply_text_edits": {
    "annotations": [],
    "signature": "apply_text_edits({text_edits}, {bufnr}, {offset_encoding})",
    "parameters": [
      ["", "text_edits"],
      ["", "bufnr"],
      ["", "offset_encoding"]
    ],
    "parameters_doc": {
      "text_edits": "(table) list of `TextEdit` objects",
      "bufnr": "(number) Buffer id",
      "offset_encoding": "(string) utf-8|utf-16|utf-32"
    },
    "doc": ["Applies a list of text edits to a buffer."],
    "return": [],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textEdit"
    ]
  },
  "apply_workspace_edit": {
    "annotations": [],
    "signature": "apply_workspace_edit({workspace_edit}, {offset_encoding})",
    "parameters": [
      ["", "workspace_edit"],
      ["", "offset_encoding"]
    ],
    "parameters_doc": {
      "workspace_edit": "(table) `WorkspaceEdit`",
      "offset_encoding": "(string) utf-8|utf-16|utf-32 (required)"
    },
    "doc": ["Applies a `WorkspaceEdit`."],
    "return": [],
    "seealso": []
  },
  "buf_attach_client": {
    "annotations": [],
    "signature": "buf_attach_client({bufnr}, {client_id})",
    "parameters": [
      ["", "bufnr"],
      ["", "client_id"]
    ],
    "parameters_doc": {
      "bufnr": "(number) Buffer handle, or 0 for current",
      "client_id": "(number) Client id"
    },
    "doc": [
      "Implements the `textDocument/did…` notifications required to track a\nbuffer for any language server.",
      "Without calling this, the server won't be notified of changes to a buffer."
    ],
    "return": [],
    "seealso": []
  },
  "buf_clear_references": {
    "annotations": [],
    "signature": "buf_clear_references({bufnr})",
    "parameters": [["", "bufnr"]],
    "parameters_doc": { "bufnr": "(number) Buffer id" },
    "doc": ["Removes document highlights from a buffer."],
    "return": [],
    "seealso": []
  },
  "buf_detach_client": {
    "annotations": [],
    "signature": "buf_detach_client({bufnr}, {client_id})",
    "parameters": [
      ["", "bufnr"],
      ["", "client_id"]
    ],
    "parameters_doc": {
      "bufnr": "(number) Buffer handle, or 0 for current",
      "client_id": "(number) Client id"
    },
    "doc": [
      "Detaches client from the specified buffer. Note: While the server is\nnotified that the text document (buffer) was closed, it is still able to\nsend notifications should it ignore this notification."
    ],
    "return": [],
    "seealso": []
  },
  "buf_highlight_references": {
    "annotations": [],
    "signature": "buf_highlight_references({bufnr}, {references}, {offset_encoding})",
    "parameters": [
      ["", "bufnr"],
      ["", "references"],
      ["", "offset_encoding"]
    ],
    "parameters_doc": {
      "bufnr": "(number) Buffer id",
      "references": "(table) List of `DocumentHighlight` objects to\n                       highlight",
      "offset_encoding": "(string) One of \"utf-8\", \"utf-16\", \"utf-32\"."
    },
    "doc": ["Shows a list of document highlights for a certain buffer."],
    "return": [],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#documentHighlight"
    ]
  },
  "buf_is_attached": {
    "annotations": [],
    "signature": "buf_is_attached({bufnr}, {client_id})",
    "parameters": [
      ["", "bufnr"],
      ["", "client_id"]
    ],
    "parameters_doc": {
      "bufnr": "(number) Buffer handle, or 0 for current",
      "client_id": "(number) the client id"
    },
    "doc": ["Checks if a buffer is attached for a particular client."],
    "return": [],
    "seealso": []
  },
  "buf_notify": {
    "annotations": [],
    "signature": "buf_notify({bufnr}, {method}, {params})",
    "parameters": [
      ["", "bufnr"],
      ["", "method"],
      ["", "params"]
    ],
    "parameters_doc": {
      "bufnr": "[number] (optional): The number of the buffer",
      "method": "[string]: Name of the request method",
      "params": "[string]: Arguments to send to the server"
    },
    "doc": ["Send a notification to a server"],
    "return": ["true if any client returns true; false otherwise"],
    "seealso": []
  },
  "buf_request_all": {
    "annotations": [],
    "signature": "buf_request_all({bufnr}, {method}, {params}, {callback})",
    "parameters": [
      ["", "bufnr"],
      ["", "method"],
      ["", "params"],
      ["", "callback"]
    ],
    "parameters_doc": {
      "bufnr": "(number) Buffer handle, or 0 for current.",
      "method": "(string) LSP method name",
      "params": "(optional, table) Parameters to send to the server",
      "callback": "(function) The callback to call when all requests are\n                finished."
    },
    "doc": [
      "Sends an async request for all active clients attached to the buffer.\nExecutes the callback on the combined result. Parameters are the same as\n|vim.lsp.buf_request()| but the return result and callback are different."
    ],
    "return": [
      "(function) A function that will cancel all requests which is the same\n    as the one returned from `buf_request`."
    ],
    "seealso": []
  },
  "buf_request_sync": {
    "annotations": [],
    "signature": "buf_request_sync({bufnr}, {method}, {params}, {timeout_ms})",
    "parameters": [
      ["", "bufnr"],
      ["", "method"],
      ["", "params"],
      ["", "timeout_ms"]
    ],
    "parameters_doc": {
      "bufnr": "(number) Buffer handle, or 0 for current.",
      "method": "(string) LSP method name",
      "params": "(optional, table) Parameters to send to the server",
      "timeout_ms": "(optional, number, default=1000) Maximum time in\n                  milliseconds to wait for a result."
    },
    "doc": [
      "Sends a request to all server and waits for the response of all of them.",
      "Calls |vim.lsp.buf_request_all()| but blocks Nvim while awaiting the\nresult. Parameters are the same as |vim.lsp.buf_request()| but the return\nresult is different. Wait maximum of {timeout_ms} (default 1000) ms."
    ],
    "return": [
      "Map of client_id:request_result. On timeout, cancel or error, returns\n    `(nil, err)` where `err` is a string describing the failure reason."
    ],
    "seealso": []
  },
  "character_offset": {
    "annotations": [],
    "signature": "character_offset({buf}, {row}, {col}, {offset_encoding})",
    "parameters": [
      ["", "buf"],
      ["", "row"],
      ["", "col"],
      ["", "offset_encoding"]
    ],
    "parameters_doc": {
      "buf": "(number) buffer number (0 for current)",
      "row": "0-indexed line",
      "col": "0-indexed byte offset in line",
      "offset_encoding": "(string) utf-8|utf-16|utf-32|nil defaults to\n                       `offset_encoding` of first client of `buf`"
    },
    "doc": ["Returns the UTF-32 and UTF-16 offsets for a position in a certain buffer."],
    "return": [
      "(number, number) `offset_encoding` index of the character in line\n    {row} column {col} in buffer {buf}"
    ],
    "seealso": []
  },
  "clear_references": {
    "annotations": [],
    "signature": "clear_references()",
    "parameters": [],
    "parameters_doc": {},
    "doc": ["Removes document highlights from current buffer."],
    "return": [],
    "seealso": []
  },
  "client": {
    "annotations": [],
    "signature": "client()",
    "parameters": [],
    "parameters_doc": {},
    "doc": [
      "LSP client object. You can get an active client object via\n|vim.lsp.get_client_by_id()| or |vim.lsp.get_active_clients()|.",
      "\n• Methods:\n  • request(method, params, [handler], bufnr) Sends a request to the\n    server. This is a thin wrapper around {client.rpc.request} with some\n    additional checking. If {handler} is not specified, If one is not\n    found there, then an error will occur. Returns: {status},\n    {[client_id]}. {status} is a boolean indicating if the notification\n    was successful. If it is `false`, then it will always be `false` (the\n    client has shutdown). If {status} is `true`, the function returns\n    {request_id} as the second result. You can use this with\n    `client.cancel_request(request_id)` to cancel the request.\n  • request_sync(method, params, timeout_ms, bufnr) Sends a request to the\n    server and synchronously waits for the response. This is a wrapper\n    around {client.request} Returns: { err=err, result=result }, a\n    dictionary, where `err` and `result` come from the |lsp-handler|. On\n    timeout, cancel or error, returns `(nil, err)` where `err` is a string\n    describing the failure reason. If the request was unsuccessful returns\n    `nil`.\n  • notify(method, params) Sends a notification to an LSP server. Returns:\n    a boolean to indicate if the notification was successful. If it is\n    false, then it will always be false (the client has shutdown).\n  • cancel_request(id) Cancels a request with a given request id. Returns:\n    same as `notify()`.\n  • stop([force]) Stops a client, optionally with force. By default, it\n    will just ask the server to shutdown without force. If you request to\n    stop a client which has previously been requested to shutdown, it will\n    automatically escalate and force shutdown.\n  • is_stopped() Checks whether a client is stopped. Returns: true if the\n    client is fully stopped.\n  • on_attach(client, bufnr) Runs the on_attach function from the client's\n    config if it was defined. Useful for buffer-local setup.\n\n• Members\n  • {id} (number): The id allocated to the client.\n  • {name} (string): If a name is specified on creation, that will be\n    used. Otherwise it is just the client id. This is used for logs and\n    messages.\n  • {rpc} (table): RPC client object, for low level interaction with the\n    client. See |vim.lsp.rpc.start()|.\n  • {offset_encoding} (string): The encoding used for communicating with\n    the server. You can modify this in the `config`'s `on_init` method\n    before text is sent to the server.\n  • {handlers} (table): The handlers used by the client as described in\n    |lsp-handler|.\n  • {requests} (table): The current pending requests in flight to the\n    server. Entries are key-value pairs with the key being the request ID\n    while the value is a table with `type`, `bufnr`, and `method`\n    key-value pairs. `type` is either \"pending\" for an active request, or\n    \"cancel\" for a cancel request.\n  • {config} (table): copy of the table that was passed by the user to\n    |vim.lsp.start_client()|.\n  • {server_capabilities} (table): Response from the server sent on\n    `initialize` describing the server's capabilities.\n\n"
    ],
    "return": [],
    "seealso": []
  },
  "client_is_stopped": {
    "annotations": [],
    "signature": "client_is_stopped({client_id})",
    "parameters": [["", "client_id"]],
    "parameters_doc": { "client_id": "(Number)" },
    "doc": ["Checks whether a client is stopped."],
    "return": ["true if client is stopped, false otherwise."],
    "seealso": []
  },
  "code_action": {
    "annotations": [],
    "signature": "code_action({options})",
    "parameters": [["", "options"]],
    "parameters_doc": {
      "options": "(table|nil) Optional table which holds the following\n               optional fields:\n               • context: (table|nil) Corresponds to `CodeActionContext` of the LSP specification:\n                 • diagnostics (table|nil): LSP`Diagnostic[]` . Inferred from the current position if not provided.\n                 • only (table|nil): List of LSP `CodeActionKind`s used to\n                   filter the code actions. Most language servers support\n                   values like `refactor` or `quickfix`.\n\n               • filter: (function|nil) Predicate taking an `CodeAction`\n                 and returning a boolean.\n               • apply: (boolean|nil) When set to `true`, and there is\n                 just one remaining action (after filtering), the action\n                 is applied without user query.\n               • range: (table|nil) Range for which code actions should be\n                 requested. If in visual mode this defaults to the active\n                 selection. Table must contain `start` and `end` keys with\n                 {row, col} tuples using mark-like indexing. See\n                 |api-indexing|"
    },
    "doc": ["Selects a code action available at the current cursor position."],
    "return": [],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction"
    ]
  },
  "completion": {
    "annotations": [],
    "signature": "completion({context})",
    "parameters": [["", "context"]],
    "parameters_doc": {
      "context": "(context support not yet implemented) Additional\n               information about the context in which a completion was\n               triggered (how it was triggered, and by which trigger\n               character, if applicable)"
    },
    "doc": [
      "Retrieves the completion items at the current cursor position. Can only be\ncalled in Insert mode."
    ],
    "return": [],
    "seealso": ["|vim.lsp.protocol.constants.CompletionTriggerKind|"]
  },
  "compute_diff": {
    "annotations": [],
    "signature": "compute_diff({___MissingCloseParenHere___})",
    "parameters": [["", "___MissingCloseParenHere___"]],
    "parameters_doc": {
      "prev_lines": "(table) list of lines",
      "curr_lines": "(table) list of lines",
      "firstline": "(number) line to begin search for first difference",
      "lastline": "(number) line to begin search in old_lines for last\n                       difference",
      "new_lastline": "(number) line to begin search in new_lines for last\n                       difference",
      "offset_encoding": "(string) encoding requested by language server"
    },
    "doc": ["Returns the range table for the difference between prev and curr lines"],
    "return": [
      "(table) TextDocumentContentChangeEvent see https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#textDocumentContentChangeEvent"
    ],
    "seealso": []
  },
  "connect": {
    "annotations": [],
    "signature": "connect({host}, {port})",
    "parameters": [
      ["", "host"],
      ["", "port"]
    ],
    "parameters_doc": { "host": "(string)", "port": "(number)" },
    "doc": [
      "Create a LSP RPC client factory that connects via TCP to the given host\nand port"
    ],
    "return": ["(function)"],
    "seealso": []
  },
  "convert_input_to_markdown_lines": {
    "annotations": [],
    "signature": "convert_input_to_markdown_lines({input}, {contents})",
    "parameters": [
      ["", "input"],
      ["", "contents"]
    ],
    "parameters_doc": {
      "input": "(`MarkedString` | `MarkedString[]` | `MarkupContent`)",
      "contents": "(table, optional, default `{}`) List of strings to extend\n                with converted lines"
    },
    "doc": [
      "Converts any of `MarkedString` | `MarkedString[]` | `MarkupContent` into a\nlist of lines containing valid markdown. Useful to populate the hover\nwindow for `textDocument/hover`, for parsing the result of\n`textDocument/signatureHelp`, and potentially others."
    ],
    "return": ["{contents}, extended with lines of converted markdown."],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_hover"
    ]
  },
  "convert_signature_help_to_markdown_lines": {
    "annotations": [],
    "signature": "convert_signature_help_to_markdown_lines({signature_help}, {ft}, {triggers})",
    "parameters": [
      ["", "signature_help"],
      ["", "ft"],
      ["", "triggers"]
    ],
    "parameters_doc": {
      "signature_help": "Response of `textDocument/SignatureHelp`",
      "ft": "optional filetype that will be use as the `lang` for\n                      the label markdown code block",
      "triggers": "optional list of trigger characters from the lsp\n                      server. used to better determine parameter offsets"
    },
    "doc": ["Converts `textDocument/SignatureHelp` response to markdown lines."],
    "return": ["list of lines of converted markdown."],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_signatureHelp"
    ]
  },
  "declaration": {
    "annotations": [],
    "signature": "declaration({options})",
    "parameters": [["", "options"]],
    "parameters_doc": {
      "options": "(table|nil) additional options\n               • reuse_win: (boolean) Jump to existing window if buffer is\n                 already open.\n               • on_list: (function) handler for list results. See\n                 |lsp-on-list-handler|"
    },
    "doc": [
      "Jumps to the declaration of the symbol under the cursor.\nNote:\n    Many servers do not implement this method. Generally, see\n    |vim.lsp.buf.definition()| instead.\n"
    ],
    "return": [],
    "seealso": []
  },
  "definition": {
    "annotations": [],
    "signature": "definition({options})",
    "parameters": [["", "options"]],
    "parameters_doc": {
      "options": "(table|nil) additional options\n               • reuse_win: (boolean) Jump to existing window if buffer is\n                 already open.\n               • on_list: (function) handler for list results. See\n                 |lsp-on-list-handler|"
    },
    "doc": ["Jumps to the definition of the symbol under the cursor."],
    "return": [],
    "seealso": []
  },
  "display": {
    "annotations": [],
    "signature": "display({lenses}, {bufnr}, {client_id})",
    "parameters": [
      ["", "lenses"],
      ["", "bufnr"],
      ["", "client_id"]
    ],
    "parameters_doc": {
      "lenses": "(table) of lenses to display (`CodeLens[] | null`)",
      "bufnr": "(number)",
      "client_id": "(number)"
    },
    "doc": ["Display the lenses using virtual text"],
    "return": [],
    "seealso": []
  },
  "document_highlight": {
    "annotations": [],
    "signature": "document_highlight()",
    "parameters": [],
    "parameters_doc": {},
    "doc": [
      "Send request to the server to resolve document highlights for the current\ntext document position. This request can be triggered by a key mapping or\nby events such as `CursorHold`, e.g.:",
      ">\nautocmd CursorHold  <buffer> lua vim.lsp.buf.document_highlight()\nautocmd CursorHoldI <buffer> lua vim.lsp.buf.document_highlight()\nautocmd CursorMoved <buffer> lua vim.lsp.buf.clear_references()\n\n<",
      "Note: Usage of |vim.lsp.buf.document_highlight()| requires the following\nhighlight groups to be defined or you won't be able to see the actual\nhighlights. |LspReferenceText| |LspReferenceRead| |LspReferenceWrite|"
    ],
    "return": [],
    "seealso": []
  },
  "document_symbol": {
    "annotations": [],
    "signature": "document_symbol({options})",
    "parameters": [["", "options"]],
    "parameters_doc": {
      "options": "(table|nil) additional options\n               • on_list: (function) handler for list results. See\n                 |lsp-on-list-handler|"
    },
    "doc": ["Lists all symbols in the current buffer in the quickfix window."],
    "return": [],
    "seealso": []
  },
  "execute_command": {
    "annotations": [],
    "signature": "execute_command({command_params})",
    "parameters": [["", "command_params"]],
    "parameters_doc": { "command_params": "(table) A valid `ExecuteCommandParams` object" },
    "doc": ["Executes an LSP server command."],
    "return": [],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_executeCommand"
    ]
  },
  "extract_completion_items": {
    "annotations": [],
    "signature": "extract_completion_items({result})",
    "parameters": [["", "result"]],
    "parameters_doc": {
      "result": "(table) The result of a `textDocument/completion` request"
    },
    "doc": [
      "Can be used to extract the completion items from a `textDocument/completion` request, which may return one of `CompletionItem[]` , `CompletionList` or null."
    ],
    "return": ["(table) List of completion items"],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specification#textDocument_completion"
    ]
  },
  "for_each_buffer_client": {
    "annotations": [],
    "signature": "for_each_buffer_client({bufnr}, {fn})",
    "parameters": [
      ["", "bufnr"],
      ["", "fn"]
    ],
    "parameters_doc": {
      "bufnr": "(number) Buffer number",
      "fn": "(function) Function to run on each client attached to buffer\n             {bufnr}. The function takes the client, client ID, and buffer\n             number as arguments. Example: >\n\n               vim.lsp.for_each_buffer_client(0, function(client, client_id, bufnr)\n                 print(vim.inspect(client))\n               end)\n\n<"
    },
    "doc": ["Invokes a function for each LSP client attached to a buffer."],
    "return": [],
    "seealso": []
  },
  "format": {
    "annotations": [],
    "signature": "format({options})",
    "parameters": [["", "options"]],
    "parameters_doc": {
      "options": "table|nil Optional table which holds the following optional\n               fields:\n               • formatting_options (table|nil): Can be used to specify\n                 FormattingOptions. Some unspecified options will be\n                 automatically derived from the current Neovim options.\n                 See https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#formattingOptions\n               • timeout_ms (integer|nil, default 1000): Time in\n                 milliseconds to block for formatting requests. No effect\n                 if async=true\n               • bufnr (number|nil): Restrict formatting to the clients\n                 attached to the given buffer, defaults to the current\n                 buffer (0).\n               • filter (function|nil): Predicate used to filter clients.\n                 Receives a client as argument and must return a boolean.\n                 Clients matching the predicate are included. Example:               • >\n\n        -- Never request typescript-language-server for formatting\n        vim.lsp.buf.format {\n          filter = function(client) return client.name ~= \"tsserver\" end\n        }\n\n<\n               • async boolean|nil If true the method won't block.\n                 Defaults to false. Editing the buffer while formatting\n                 asynchronous can lead to unexpected changes.\n               • id (number|nil): Restrict formatting to the client with\n                 ID (client.id) matching this field.\n               • name (string|nil): Restrict formatting to the client with\n                 name (client.name) matching this field.\n               • range (table|nil) Range to format. Table must contain\n                 `start` and `end` keys with {row, col} tuples using (1,0)\n                 indexing. Defaults to current selection in visual mode\n                 Defaults to `nil` in other modes, formatting the full\n                 buffer"
    },
    "doc": [
      "Formats a buffer using the attached (and optionally filtered) language\nserver clients."
    ],
    "return": [],
    "seealso": []
  },
  "format_rpc_error": {
    "annotations": [],
    "signature": "format_rpc_error({err})",
    "parameters": [["", "err"]],
    "parameters_doc": { "err": "(table) The error object" },
    "doc": ["Constructs an error message from an LSP error object."],
    "return": ["(string) The formatted error message"],
    "seealso": []
  },
  "formatexpr": {
    "annotations": [],
    "signature": "formatexpr({opts})",
    "parameters": [["", "opts"]],
    "parameters_doc": {
      "opts": "(table) options for customizing the formatting expression\n            which takes the following optional keys:\n            • timeout_ms (default 500ms). The timeout period for the\n              formatting request."
    },
    "doc": [
      "Provides an interface between the built-in client and a `formatexpr`\nfunction.",
      "Currently only supports a single client. This can be set via `setlocal\nformatexpr=v:lua.vim.lsp.formatexpr()` but will typically or in\n`on_attach` via `vim.api.nvim_buf_set_option(bufnr, 'formatexpr',\n'v:lua.vim.lsp.formatexpr(#{timeout_ms:250})')`."
    ],
    "return": [],
    "seealso": []
  },
  "formatting": {
    "annotations": [],
    "signature": "formatting({options})",
    "parameters": [["", "options"]],
    "parameters_doc": {
      "options": "(table|nil) Can be used to specify FormattingOptions. Some\n               unspecified options will be automatically derived from the\n               current Neovim options."
    },
    "doc": ["Formats the current buffer."],
    "return": [],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting"
    ]
  },
  "formatting_seq_sync": {
    "annotations": [],
    "signature": "formatting_seq_sync({options}, {timeout_ms}, {order})",
    "parameters": [
      ["", "options"],
      ["", "timeout_ms"],
      ["", "order"]
    ],
    "parameters_doc": {
      "options": "(table|nil) `FormattingOptions` entries",
      "timeout_ms": "(number|nil) Request timeout",
      "order": "(table|nil) List of client names. Formatting is\n                  requested from clients in the following order: first all\n                  clients that are not in the `order` list, then the\n                  remaining clients in the order as they occur in the\n                  `order` list."
    },
    "doc": [
      "Formats the current buffer by sequentially requesting formatting from\nattached clients.",
      "Useful when multiple clients with formatting capability are attached.",
      "Since it's synchronous, can be used for running on save, to make sure\nbuffer is formatted prior to being saved. {timeout_ms} is passed on to the\n|vim.lsp.client| `request_sync` method. Example: >\n\n vim.api.nvim_command[[autocmd BufWritePre <buffer> lua vim.lsp.buf.formatting_seq_sync()]]\n \n<"
    ],
    "return": [],
    "seealso": []
  },
  "formatting_sync": {
    "annotations": [],
    "signature": "formatting_sync({options}, {timeout_ms})",
    "parameters": [
      ["", "options"],
      ["", "timeout_ms"]
    ],
    "parameters_doc": {
      "options": "(table|nil) with valid `FormattingOptions` entries",
      "timeout_ms": "(number) Request timeout"
    },
    "doc": [
      "Performs |vim.lsp.buf.formatting()| synchronously.",
      "Useful for running on save, to make sure buffer is formatted prior to\nbeing saved. {timeout_ms} is passed on to |vim.lsp.buf_request_sync()|.\nExample:",
      ">\n\n autocmd BufWritePre <buffer> lua vim.lsp.buf.formatting_sync()\n \n<"
    ],
    "return": [],
    "seealso": ["|vim.lsp.buf.formatting_seq_sync|"]
  },
  "get": {
    "annotations": [],
    "signature": "get({bufnr})",
    "parameters": [["", "bufnr"]],
    "parameters_doc": {
      "bufnr": "(number) Buffer number. 0 can be used for the current buffer."
    },
    "doc": ["Return all lenses for the given buffer"],
    "return": ["(table) (`CodeLens[]`)"],
    "seealso": []
  },
  "get_active_clients": {
    "annotations": [],
    "signature": "get_active_clients({filter})",
    "parameters": [["", "filter"]],
    "parameters_doc": {
      "filter": "(table|nil) A table with key-value pairs used to filter the\n              returned clients. The available keys are:\n              • id (number): Only return clients with the given id\n              • bufnr (number): Only return clients attached to this\n                buffer\n              • name (string): Only return clients with the given name"
    },
    "doc": ["Get active clients."],
    "return": ["(table) List of |vim.lsp.client| objects"],
    "seealso": []
  },
  "get_buffers_by_client_id": {
    "annotations": [],
    "signature": "get_buffers_by_client_id({client_id})",
    "parameters": [["", "client_id"]],
    "parameters_doc": { "client_id": "(number) client id" },
    "doc": ["Returns list of buffers attached to client_id."],
    "return": ["list of buffer ids"],
    "seealso": []
  },
  "get_client_by_id": {
    "annotations": [],
    "signature": "get_client_by_id({client_id})",
    "parameters": [["", "client_id"]],
    "parameters_doc": { "client_id": "(number) client id" },
    "doc": [
      "Gets a client by id, or nil if the id is invalid. The returned client may\nnot yet be fully initialized."
    ],
    "return": ["|vim.lsp.client| object, or nil"],
    "seealso": []
  },
  "get_effective_tabstop": {
    "annotations": [],
    "signature": "get_effective_tabstop({bufnr})",
    "parameters": [["", "bufnr"]],
    "parameters_doc": { "bufnr": "(number|nil): Buffer handle, defaults to current" },
    "doc": ["Returns indentation size."],
    "return": ["(number) indentation size"],
    "seealso": ["|shiftwidth|"]
  },
  "get_filename": {
    "annotations": [],
    "signature": "get_filename()",
    "parameters": [],
    "parameters_doc": {},
    "doc": ["Returns the log filename."],
    "return": ["(string) log filename"],
    "seealso": []
  },
  "get_level": {
    "annotations": [],
    "signature": "get_level()",
    "parameters": [],
    "parameters_doc": {},
    "doc": ["Gets the current log level."],
    "return": ["(string) current log level"],
    "seealso": []
  },
  "get_log_path": {
    "annotations": [],
    "signature": "get_log_path()",
    "parameters": [],
    "parameters_doc": {},
    "doc": ["Gets the path of the logfile used by the LSP client."],
    "return": ["(String) Path to logfile."],
    "seealso": []
  },
  "get_namespace": {
    "annotations": [],
    "signature": "get_namespace({client_id})",
    "parameters": [["", "client_id"]],
    "parameters_doc": { "client_id": "(number) The id of the LSP client" },
    "doc": [
      "Get the diagnostic namespace associated with an LSP client\n|vim.diagnostic|."
    ],
    "return": [],
    "seealso": []
  },
  "hover": {
    "annotations": [],
    "signature": "hover({_}, {result}, {ctx}, {config})",
    "parameters": [
      ["", "_"],
      ["", "result"],
      ["", "ctx"],
      ["", "config"]
    ],
    "parameters_doc": {
      "config": "(table) Configuration table.\n              • border: (default=nil)\n                • Add borders to the floating window\n                • See |nvim_open_win()|"
    },
    "doc": [
      "|lsp-handler| for the method \"textDocument/hover\" >\n\n vim.lsp.handlers[\"textDocument/hover\"] = vim.lsp.with(\n   vim.lsp.handlers.hover, {\n     -- Use a sharp border with `FloatBorder` highlights\n     border = \"single\"\n   }\n )\n \n<"
    ],
    "return": [],
    "seealso": []
  },
  "implementation": {
    "annotations": [],
    "signature": "implementation({options})",
    "parameters": [["", "options"]],
    "parameters_doc": {
      "options": "(table|nil) additional options\n               • on_list: (function) handler for list results. See\n                 |lsp-on-list-handler|"
    },
    "doc": [
      "Lists all the implementations for the symbol under the cursor in the\nquickfix window."
    ],
    "return": [],
    "seealso": []
  },
  "incoming_calls": {
    "annotations": [],
    "signature": "incoming_calls()",
    "parameters": [],
    "parameters_doc": {},
    "doc": [
      "Lists all the call sites of the symbol under the cursor in the |quickfix|\nwindow. If the symbol can resolve to multiple items, the user can pick one\nin the |inputlist|."
    ],
    "return": [],
    "seealso": []
  },
  "jump_to_location": {
    "annotations": [],
    "signature": "jump_to_location({location}, {offset_encoding}, {reuse_win})",
    "parameters": [
      ["", "location"],
      ["", "offset_encoding"],
      ["", "reuse_win"]
    ],
    "parameters_doc": {
      "location": "(table) (`Location`|`LocationLink`)",
      "offset_encoding": "(string) utf-8|utf-16|utf-32 (required)",
      "reuse_win": "(boolean) Jump to existing window if buffer is\n                       already opened."
    },
    "doc": ["Jumps to a location."],
    "return": ["`true` if the jump succeeded"],
    "seealso": []
  },
  "list_workspace_folders": {
    "annotations": [],
    "signature": "list_workspace_folders()",
    "parameters": [],
    "parameters_doc": {},
    "doc": ["List workspace folders."],
    "return": [],
    "seealso": []
  },
  "locations_to_items": {
    "annotations": [],
    "signature": "locations_to_items({locations}, {offset_encoding})",
    "parameters": [
      ["", "locations"],
      ["", "offset_encoding"]
    ],
    "parameters_doc": {
      "locations": "(table) list of `Location`s or `LocationLink`s",
      "offset_encoding": "(string) offset_encoding for locations\n                       utf-8|utf-16|utf-32"
    },
    "doc": [
      "Returns the items with the byte position calculated correctly and in\nsorted order, for display in quickfix and location lists.",
      "The result can be passed to the {list} argument of |setqflist()| or\n|setloclist()|."
    ],
    "return": ["(table) list of items"],
    "seealso": []
  },
  "lookup_section": {
    "annotations": [],
    "signature": "lookup_section({settings}, {section})",
    "parameters": [
      ["", "settings"],
      ["", "section"]
    ],
    "parameters_doc": {
      "settings": "a table of language server settings",
      "section": "a string indicating the field of the settings table"
    },
    "doc": ["Helper function to return nested values in language server settings"],
    "return": ["(table or string) The value of settings accessed via section"],
    "seealso": []
  },
  "make_client_capabilities": {
    "annotations": [],
    "signature": "make_client_capabilities()",
    "parameters": [],
    "parameters_doc": {},
    "doc": [
      "Gets a new ClientCapabilities object describing the LSP client\ncapabilities."
    ],
    "return": [],
    "seealso": []
  },
  "make_floating_popup_options": {
    "annotations": [],
    "signature": "make_floating_popup_options({width}, {height}, {opts})",
    "parameters": [
      ["", "width"],
      ["", "height"],
      ["", "opts"]
    ],
    "parameters_doc": {
      "width": "(number) window width (in character cells)",
      "height": "(number) window height (in character cells)",
      "opts": "(table, optional)\n              • offset_x (number) offset to add to `col`\n              • offset_y (number) offset to add to `row`\n              • border (string or table) override `border`\n              • focusable (string or table) override `focusable`\n              • zindex (string or table) override `zindex`, defaults to 50"
    },
    "doc": [
      "Creates a table with sensible default options for a floating window. The\ntable can be passed to |nvim_open_win()|."
    ],
    "return": ["(table) Options"],
    "seealso": []
  },
  "make_formatting_params": {
    "annotations": [],
    "signature": "make_formatting_params({options})",
    "parameters": [["", "options"]],
    "parameters_doc": { "options": "(table|nil) with valid `FormattingOptions` entries" },
    "doc": [
      "Creates a `DocumentFormattingParams` object for the current buffer and\ncursor position."
    ],
    "return": ["`DocumentFormattingParams` object"],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_formatting"
    ]
  },
  "make_given_range_params": {
    "annotations": [],
    "signature": "make_given_range_params({start_pos}, {end_pos}, {bufnr}, {offset_encoding})",
    "parameters": [
      ["", "start_pos"],
      ["", "end_pos"],
      ["", "bufnr"],
      ["", "offset_encoding"]
    ],
    "parameters_doc": {
      "start_pos": "number[]|nil {row, col} mark-indexed position.\n                       Defaults to the start of the last visual selection.",
      "end_pos": "number[]|nil {row, col} mark-indexed position.\n                       Defaults to the end of the last visual selection.",
      "bufnr": "(number|nil) buffer handle or 0 for current,\n                       defaults to current",
      "offset_encoding": "\"utf-8\"|\"utf-16\"|\"utf-32\"|nil defaults to\n                       `offset_encoding` of first client of `bufnr`"
    },
    "doc": [
      "Using the given range in the current buffer, creates an object that is\nsimilar to |vim.lsp.util.make_range_params()|."
    ],
    "return": [
      "{ textDocument = { uri = `current_file_uri` }, range = { start =\n    `start_position`, end = `end_position` } }"
    ],
    "seealso": []
  },
  "make_position_params": {
    "annotations": [],
    "signature": "make_position_params({window}, {offset_encoding})",
    "parameters": [
      ["", "window"],
      ["", "offset_encoding"]
    ],
    "parameters_doc": {
      "window": "number|nil: window handle or 0 for current,\n                       defaults to current",
      "offset_encoding": "(string) utf-8|utf-16|utf-32|nil defaults to\n                       `offset_encoding` of first client of buffer of\n                       `window`"
    },
    "doc": [
      "Creates a `TextDocumentPositionParams` object for the current buffer and\ncursor position."
    ],
    "return": ["`TextDocumentPositionParams` object"],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentPositionParams"
    ]
  },
  "make_range_params": {
    "annotations": [],
    "signature": "make_range_params({window}, {offset_encoding})",
    "parameters": [
      ["", "window"],
      ["", "offset_encoding"]
    ],
    "parameters_doc": {
      "window": "number|nil: window handle or 0 for current,\n                       defaults to current",
      "offset_encoding": "\"utf-8\"|\"utf-16\"|\"utf-32\"|nil defaults to\n                       `offset_encoding` of first client of buffer of\n                       `window`"
    },
    "doc": [
      "Using the current position in the current buffer, creates an object that\ncan be used as a building block for several LSP requests, such as\n`textDocument/codeAction`, `textDocument/colorPresentation`,\n`textDocument/rangeFormatting`."
    ],
    "return": [
      "{ textDocument = { uri = `current_file_uri` }, range = { start =\n    `current_position`, end = `current_position` } }"
    ],
    "seealso": []
  },
  "make_text_document_params": {
    "annotations": [],
    "signature": "make_text_document_params({bufnr})",
    "parameters": [["", "bufnr"]],
    "parameters_doc": { "bufnr": "number|nil: Buffer handle, defaults to current" },
    "doc": ["Creates a `TextDocumentIdentifier` object for the current buffer."],
    "return": ["`TextDocumentIdentifier`"],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentIdentifier"
    ]
  },
  "make_workspace_params": {
    "annotations": [],
    "signature": "make_workspace_params({added}, {removed})",
    "parameters": [
      ["", "added"],
      ["", "removed"]
    ],
    "parameters_doc": { "added": "", "removed": "" },
    "doc": ["Create the workspace params"],
    "return": [],
    "seealso": []
  },
  "notify": {
    "annotations": [],
    "signature": "notify({method}, {params})",
    "parameters": [
      ["", "method"],
      ["", "params"]
    ],
    "parameters_doc": {
      "method": "(string) The invoked LSP method",
      "params": "(table|nil): Parameters for the invoked LSP method"
    },
    "doc": ["Sends a notification to the LSP server."],
    "return": ["(bool) `true` if notification could be sent, `false` if not"],
    "seealso": []
  },
  "omnifunc": {
    "annotations": [],
    "signature": "omnifunc({findstart}, {base})",
    "parameters": [
      ["", "findstart"],
      ["", "base"]
    ],
    "parameters_doc": {
      "findstart": "0 or 1, decides behavior",
      "base": "If findstart=0, text to match against"
    },
    "doc": ["Implements 'omnifunc' compatible LSP completion."],
    "return": [
      "(number) Decided by {findstart}:\n    • findstart=0: column where the completion starts, or -2 or -3\n    • findstart=1: list of matches (actually just calls |complete()|)\n"
    ],
    "seealso": ["|complete-functions|", "|complete-items|", "|CompleteDone|"]
  },
  "on_codelens": {
    "annotations": [],
    "signature": "on_codelens({err}, {result}, {ctx}, {_})",
    "parameters": [
      ["", "err"],
      ["", "result"],
      ["", "ctx"],
      ["", "_"]
    ],
    "parameters_doc": {},
    "doc": ["|lsp-handler| for the method `textDocument/codeLens`"],
    "return": [],
    "seealso": []
  },
  "on_publish_diagnostics": {
    "annotations": [],
    "signature": "on_publish_diagnostics({_}, {result}, {ctx}, {config})",
    "parameters": [
      ["", "_"],
      ["", "result"],
      ["", "ctx"],
      ["", "config"]
    ],
    "parameters_doc": {
      "config": "(table) Configuration table (see |vim.diagnostic.config()|)."
    },
    "doc": [
      "|lsp-handler| for the method \"textDocument/publishDiagnostics\"",
      "See |vim.diagnostic.config()| for configuration options. Handler-specific\nconfiguration can be set using |vim.lsp.with()|: >\n\n vim.lsp.handlers[\"textDocument/publishDiagnostics\"] = vim.lsp.with(\n   vim.lsp.diagnostic.on_publish_diagnostics, {\n     -- Enable underline, use default values\n     underline = true,\n     -- Enable virtual text, override spacing to 4\n     virtual_text = {\n       spacing = 4,\n     },\n     -- Use a function to dynamically turn signs off\n     -- and on, using buffer local variables\n     signs = function(namespace, bufnr)\n       return vim.b[bufnr].show_signs == true\n     end,\n     -- Disable a feature\n     update_in_insert = false,\n   }\n )\n \n<"
    ],
    "return": [],
    "seealso": []
  },
  "open_floating_preview": {
    "annotations": [],
    "signature": "open_floating_preview({contents}, {syntax}, {opts})",
    "parameters": [
      ["", "contents"],
      ["", "syntax"],
      ["", "opts"]
    ],
    "parameters_doc": {
      "contents": "(table) of lines to show in window",
      "syntax": "(string) of syntax to set for opened buffer",
      "opts": "(table) with optional fields (additional keys are passed\n                on to |vim.api.nvim_open_win()|)\n                • height: (number) height of floating window\n                • width: (number) width of floating window\n                • wrap: (boolean, default true) wrap long lines\n                • wrap_at: (number) character to wrap at for computing\n                  height when wrap is enabled\n                • max_width: (number) maximal width of floating window\n                • max_height: (number) maximal height of floating window\n                • pad_top: (number) number of lines to pad contents at top\n                • pad_bottom: (number) number of lines to pad contents at\n                  bottom\n                • focus_id: (string) if a popup with this id is opened,\n                  then focus it\n                • close_events: (table) list of events that closes the\n                  floating window\n                • focusable: (boolean, default true) Make float focusable\n                • focus: (boolean, default true) If `true`, and if\n                  {focusable} is also `true`, focus an existing floating\n                  window with the same {focus_id}"
    },
    "doc": ["Shows contents in a floating window."],
    "return": [
      "bufnr,winnr buffer and window number of the newly created floating\n    preview window"
    ],
    "seealso": []
  },
  "outgoing_calls": {
    "annotations": [],
    "signature": "outgoing_calls()",
    "parameters": [],
    "parameters_doc": {},
    "doc": [
      "Lists all the items that are called by the symbol under the cursor in the\n|quickfix| window. If the symbol can resolve to multiple items, the user\ncan pick one in the |inputlist|."
    ],
    "return": [],
    "seealso": []
  },
  "parse_snippet": {
    "annotations": [],
    "signature": "parse_snippet({input})",
    "parameters": [["", "input"]],
    "parameters_doc": { "input": "(string) unparsed snippet" },
    "doc": ["Parses snippets in a completion entry."],
    "return": ["(string) parsed snippet"],
    "seealso": []
  },
  "preview_location": {
    "annotations": [],
    "signature": "preview_location({location}, {opts})",
    "parameters": [
      ["", "location"],
      ["", "opts"]
    ],
    "parameters_doc": { "location": "a single `Location` or `LocationLink`" },
    "doc": [
      "Previews a location in a floating window",
      "behavior depends on type of location:\n• for Location, range is shown (e.g., function definition)\n• for LocationLink, targetRange is shown (e.g., body of function\n  definition)\n"
    ],
    "return": ["(bufnr,winnr) buffer and window number of floating window or nil"],
    "seealso": []
  },
  "range_code_action": {
    "annotations": [],
    "signature": "range_code_action({context}, {start_pos}, {end_pos})",
    "parameters": [
      ["", "context"],
      ["", "start_pos"],
      ["", "end_pos"]
    ],
    "parameters_doc": {
      "context": "(table|nil) `CodeActionContext` of the LSP specification:\n                 • diagnostics: (table|nil) LSP`Diagnostic[]` . Inferred from the current position if not provided.\n                 • only: (table|nil) List of LSP `CodeActionKind`s used to\n                   filter the code actions. Most language servers support\n                   values like `refactor` or `quickfix`.",
      "start_pos": "({number, number}, optional) mark-indexed position.\n                 Defaults to the start of the last visual selection.",
      "end_pos": "({number, number}, optional) mark-indexed position.\n                 Defaults to the end of the last visual selection."
    },
    "doc": ["Performs |vim.lsp.buf.code_action()| for a given range."],
    "return": [],
    "seealso": []
  },
  "range_formatting": {
    "annotations": [],
    "signature": "range_formatting({options}, {start_pos}, {end_pos})",
    "parameters": [
      ["", "options"],
      ["", "start_pos"],
      ["", "end_pos"]
    ],
    "parameters_doc": {
      "options": "Table with valid `FormattingOptions` entries.",
      "start_pos": "({number, number}, optional) mark-indexed position.\n                 Defaults to the start of the last visual selection.",
      "end_pos": "({number, number}, optional) mark-indexed position.\n                 Defaults to the end of the last visual selection."
    },
    "doc": ["Formats a given range."],
    "return": [],
    "seealso": []
  },
  "references": {
    "annotations": [],
    "signature": "references({context}, {options})",
    "parameters": [
      ["", "context"],
      ["", "options"]
    ],
    "parameters_doc": {
      "context": "(table) Context for the request",
      "options": "(table|nil) additional options\n               • on_list: (function) handler for list results. See\n                 |lsp-on-list-handler|"
    },
    "doc": [
      "Lists all the references to the symbol under the cursor in the quickfix\nwindow."
    ],
    "return": [],
    "seealso": [
      "https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_references"
    ]
  },
  "refresh": {
    "annotations": [],
    "signature": "refresh()",
    "parameters": [],
    "parameters_doc": {},
    "doc": [
      "Refresh the codelens for the current buffer",
      "It is recommended to trigger this using an autocmd or via keymap.",
      ">\n  autocmd BufEnter,CursorHold,InsertLeave <buffer> lua vim.lsp.codelens.refresh()\n\n<"
    ],
    "return": [],
    "seealso": []
  },
  "remove_workspace_folder": {
    "annotations": [],
    "signature": "remove_workspace_folder({workspace_folder})",
    "parameters": [["", "workspace_folder"]],
    "parameters_doc": {},
    "doc": [
      "Remove the folder at path from the workspace folders. If {path} is not\nprovided, the user will be prompted for a path using |input()|."
    ],
    "return": [],
    "seealso": []
  },
  "rename": {
    "annotations": [],
    "signature": "rename({old_fname}, {new_fname}, {opts})",
    "parameters": [
      ["", "old_fname"],
      ["", "new_fname"],
      ["", "opts"]
    ],
    "parameters_doc": { "opts": "(table)" },
    "doc": ["Rename old_fname to new_fname"],
    "return": [],
    "seealso": []
  },
  "request": {
    "annotations": [],
    "signature": "request({method}, {params}, {callback}, {notify_reply_callback})",
    "parameters": [
      ["", "method"],
      ["", "params"],
      ["", "callback"],
      ["", "notify_reply_callback"]
    ],
    "parameters_doc": {
      "method": "(string) The invoked LSP method",
      "params": "(table|nil) Parameters for the invoked LSP\n                             method",
      "callback": "(function) Callback to invoke",
      "notify_reply_callback": "(function|nil) Callback to invoke as soon as\n                             a request is no longer pending"
    },
    "doc": ["Sends a request to the LSP server and runs {callback} upon response."],
    "return": [
      "(bool, number) `(true, message_id)` if request could be sent, `false`\n    if not"
    ],
    "seealso": []
  },
  "resolve_capabilities": {
    "annotations": [],
    "signature": "resolve_capabilities({server_capabilities})",
    "parameters": [["", "server_capabilities"]],
    "parameters_doc": {
      "server_capabilities": "(table) Table of capabilities supported by the\n                           server"
    },
    "doc": ["Creates a normalized object describing LSP server capabilities."],
    "return": ["(table) Normalized table of capabilities"],
    "seealso": []
  },
  "rpc_response_error": {
    "annotations": [],
    "signature": "rpc_response_error({code}, {message}, {data})",
    "parameters": [
      ["", "code"],
      ["", "message"],
      ["", "data"]
    ],
    "parameters_doc": {
      "code": "(number) RPC error code defined in\n               `vim.lsp.protocol.ErrorCodes`",
      "message": "(string|nil) arbitrary message to send to server",
      "data": "any|nil arbitrary data to send to server"
    },
    "doc": ["Creates an RPC response object/table."],
    "return": [],
    "seealso": []
  },
  "run": {
    "annotations": [],
    "signature": "run()",
    "parameters": [],
    "parameters_doc": {},
    "doc": ["Run the code lens in the current line"],
    "return": [],
    "seealso": []
  },
  "save": {
    "annotations": [],
    "signature": "save({lenses}, {bufnr}, {client_id})",
    "parameters": [
      ["", "lenses"],
      ["", "bufnr"],
      ["", "client_id"]
    ],
    "parameters_doc": {
      "lenses": "(table) of lenses to store (`CodeLens[] | null`)",
      "bufnr": "(number)",
      "client_id": "(number)"
    },
    "doc": ["Store lenses for a specific buffer and client"],
    "return": [],
    "seealso": []
  },
  "server_ready": {
    "annotations": [],
    "signature": "server_ready()",
    "parameters": [],
    "parameters_doc": {},
    "doc": [
      "Checks whether the language servers attached to the current buffer are\nready."
    ],
    "return": ["`true` if server responds."],
    "seealso": []
  },
  "set_format_func": {
    "annotations": [],
    "signature": "set_format_func({handle})",
    "parameters": [["", "handle"]],
    "parameters_doc": {
      "handle": "(function) function to apply to logging arguments, pass\n              vim.inspect for multi-line formatting"
    },
    "doc": ["Sets formatting function used to format logs"],
    "return": [],
    "seealso": []
  },
  "set_level": {
    "annotations": [],
    "signature": "set_level({level})",
    "parameters": [["", "level"]],
    "parameters_doc": { "level": "(string or number) One of `vim.lsp.log.levels`" },
    "doc": ["Sets the current log level."],
    "return": [],
    "seealso": []
  },
  "set_lines": {
    "annotations": [],
    "signature": "set_lines({lines}, {A}, {B}, {new_lines})",
    "parameters": [
      ["", "lines"],
      ["", "A"],
      ["", "B"],
      ["", "new_lines"]
    ],
    "parameters_doc": {
      "lines": "(table) Original list of strings",
      "A": "(table) Start position; a 2-tuple of {line, col} numbers",
      "B": "(table) End position; a 2-tuple of {line, col} numbers",
      "new_lines": "A list of strings to replace the original"
    },
    "doc": ["Replaces text in a range with new text.", "CAUTION: Changes in-place!"],
    "return": ["(table) The modified {lines} object"],
    "seealso": []
  },
  "set_log_level": {
    "annotations": [],
    "signature": "set_log_level({level})",
    "parameters": [["", "level"]],
    "parameters_doc": {
      "level": "[number|string] the case insensitive level name or number"
    },
    "doc": [
      "Sets the global log level for LSP logging.",
      "Levels by name: \"TRACE\", \"DEBUG\", \"INFO\", \"WARN\", \"ERROR\", \"OFF\"",
      "Level numbers begin with \"TRACE\" at 0",
      "Use `lsp.log_levels` for reverse lookup."
    ],
    "return": [],
    "seealso": ["|vim.lsp.log_levels|"]
  },
  "should_log": {
    "annotations": [],
    "signature": "should_log({level})",
    "parameters": [["", "level"]],
    "parameters_doc": { "level": "(number) log level" },
    "doc": ["Checks whether the level is sufficient for logging."],
    "return": ["(bool) true if would log, false if not"],
    "seealso": []
  },
  "signature_help": {
    "annotations": [],
    "signature": "signature_help({_}, {result}, {ctx}, {config})",
    "parameters": [
      ["", "_"],
      ["", "result"],
      ["", "ctx"],
      ["", "config"]
    ],
    "parameters_doc": {
      "config": "(table) Configuration table.\n              • border: (default=nil)\n                • Add borders to the floating window\n                • See |vim.api.nvim_open_win()|"
    },
    "doc": [
      "|lsp-handler| for the method \"textDocument/signatureHelp\". The active\nparameter is highlighted with |hl-LspSignatureActiveParameter|. >\n\n vim.lsp.handlers[\"textDocument/signatureHelp\"] = vim.lsp.with(\n   vim.lsp.handlers.signature_help, {\n     -- Use a sharp border with `FloatBorder` highlights\n     border = \"single\"\n   }\n )\n \n<"
    ],
    "return": [],
    "seealso": []
  },
  "start": {
    "annotations": [],
    "signature": "start({cmd}, {cmd_args}, {dispatchers}, {extra_spawn_params})",
    "parameters": [
      ["", "cmd"],
      ["", "cmd_args"],
      ["", "dispatchers"],
      ["", "extra_spawn_params"]
    ],
    "parameters_doc": {
      "cmd": "(string) Command to start the LSP server.",
      "cmd_args": "(table) List of additional string arguments to\n                          pass to {cmd}.",
      "dispatchers": "(table|nil) Dispatchers for LSP message types.\n                          Valid dispatcher names are:\n                          • `\"notification\"`\n                          • `\"server_request\"`\n                          • `\"on_error\"`\n                          • `\"on_exit\"`",
      "extra_spawn_params": "(table|nil) Additional context for the LSP\n                          server process. May contain:\n                          • {cwd} (string) Working directory for the LSP\n                            server process\n                          • {env} (table) Additional environment variables\n                            for LSP server process"
    },
    "doc": [
      "Starts an LSP server process and create an LSP RPC client object to\ninteract with it. Communication with the spawned process happens via\nstdio. For communication via TCP, spawn a process manually and use\n|vim.lsp.rpc.connect|"
    ],
    "return": [
      "Client RPC object.",
      "Methods:\n    • `notify()` |vim.lsp.rpc.notify()|\n    • `request()` |vim.lsp.rpc.request()|\n    • `is_closing()` returns a boolean indicating if the RPC is closing.\n    • `terminate()` terminates the RPC client.\n"
    ],
    "seealso": []
  },
  "start_client": {
    "annotations": [],
    "signature": "start_client({config})",
    "parameters": [["", "config"]],
    "parameters_doc": {
      "cmd": "(table|string|fun(dispatchers: table):table)\n                         command string or list treated like |jobstart|.\n                         The command must launch the language server\n                         process. `cmd` can also be a function that\n                         creates an RPC client. The function receives a\n                         dispatchers table and must return a table with\n                         the functions `request`, `notify`, `is_closing`\n                         and `terminate` See |vim.lsp.rpc.request| and\n                         |vim.lsp.rpc.notify| For TCP there is a built-in\n                         rpc client factory: |vim.lsp.rpc.connect|",
      "cmd_cwd": "(string, default=|getcwd()|) Directory to launch\n                         the `cmd` process. Not related to `root_dir`.",
      "cmd_env": "(table) Environment flags to pass to the LSP on\n                         spawn. Can be specified using keys like a map or\n                         as a list with `k=v` pairs or both. Non-string values are coerced to\n                         string. Example: >\n\n { \"PRODUCTION=true\"; \"TEST=123\"; PORT = 8080; HOST = \"0.0.0.0\"; }\n\n<",
      "detached": "(boolean, default true) Daemonize the server\n                         process so that it runs in a separate process\n                         group from Nvim. Nvim will shutdown the process\n                         on exit, but if Nvim fails to exit cleanly this\n                         could leave behind orphaned server processes.",
      "workspace_folders": "(table) List of workspace folders passed to the\n                         language server. For backwards compatibility\n                         rootUri and rootPath will be derived from the\n                         first workspace folder in this list. See\n                         `workspaceFolders` in the LSP spec.",
      "capabilities": "Map overriding the default capabilities defined\n                         by |vim.lsp.protocol.make_client_capabilities()|,\n                         passed to the language server on initialization.\n                         Hint: use make_client_capabilities() and modify\n                         its result.\n                         • Note: To send an empty dictionary use\n                           `{[vim.type_idx]=vim.types.dictionary}`, else\n                           it will be encoded as an array.",
      "handlers": "Map of language server method names to\n                         |lsp-handler|",
      "settings": "Map with language server specific settings. These\n                         are returned to the language server if requested\n                         via `workspace/configuration`. Keys are\n                         case-sensitive.",
      "commands": "(table) Table that maps string of clientside\n                         commands to user-defined functions. Commands\n                         passed to start_client take precedence over the\n                         global command registry. Each key must be a\n                         unique command name, and the value is a function\n                         which is called if any LSP action (code action,\n                         code lenses, ...) triggers the command.",
      "init_options": "Values to pass in the initialization request as\n                         `initializationOptions`. See `initialize` in the\n                         LSP spec.",
      "name": "(string, default=client-id) Name in log messages.",
      "get_language_id": "function(bufnr, filetype) -> language ID as\n                         string. Defaults to the filetype.",
      "offset_encoding": "(default=\"utf-16\") One of \"utf-8\", \"utf-16\", or\n                         \"utf-32\" which is the encoding that the LSP\n                         server expects. Client does not verify this is\n                         correct.",
      "on_error": "Callback with parameters (code, ...), invoked\n                         when the client operation throws an error. `code`\n                         is a number describing the error. Other arguments\n                         may be passed depending on the error kind. See\n                         |vim.lsp.rpc.client_errors| for possible errors.\n                         Use `vim.lsp.rpc.client_errors[code]` to get\n                         human-friendly name.",
      "before_init": "Callback with parameters (initialize_params,\n                         config) invoked before the LSP \"initialize\"\n                         phase, where `params` contains the parameters\n                         being sent to the server and `config` is the\n                         config that was passed to\n                         |vim.lsp.start_client()|. You can use this to\n                         modify parameters before they are sent.",
      "on_init": "Callback (client, initialize_result) invoked\n                         after LSP \"initialize\", where `result` is a table\n                         of `capabilities` and anything else the server\n                         may send. For example, clangd sends\n                         `initialize_result.offsetEncoding` if\n                         `capabilities.offsetEncoding` was sent to it. You\n                         can only modify the `client.offset_encoding` here\n                         before any notifications are sent. Most language\n                         servers expect to be sent client specified\n                         settings after initialization. Neovim does not\n                         make this assumption. A\n                         `workspace/didChangeConfiguration` notification\n                         should be sent to the server during on_init.",
      "on_exit": "Callback (code, signal, client_id) invoked on\n                         client exit.\n                         • code: exit code of the process\n                         • signal: number describing the signal used to\n                           terminate (if any)\n                         • client_id: client handle",
      "on_attach": "Callback (client, bufnr) invoked when client\n                         attaches to a buffer.",
      "trace": "\"off\" | \"messages\" | \"verbose\" | nil passed\n                         directly to the language server in the initialize\n                         request. Invalid/empty values will default to\n                         \"off\"",
      "flags": "A table with flags for the client. The current\n                         (experimental) flags are:\n                         • allow_incremental_sync (bool, default true):\n                           Allow using incremental sync for buffer edits\n                         • debounce_text_changes (number, default 150):\n                           Debounce didChange notifications to the server\n                           by the given number in milliseconds. No\n                           debounce occurs if nil\n                         • exit_timeout (number|boolean, default false):\n                           Milliseconds to wait for server to exit cleanly\n                           after sending the 'shutdown' request before\n                           sending kill -15. If set to false, nvim exits\n                           immediately after sending the 'shutdown'\n                           request to the server.",
      "root_dir": "(string) Directory where the LSP server will base\n                         its workspaceFolders, rootUri, and rootPath on\n                         initialization."
    },
    "doc": [
      "Starts and initializes a client with the given configuration.",
      "Parameter `cmd` is required.",
      "The following parameters describe fields in the {config} table."
    ],
    "return": [
      "Client id. |vim.lsp.get_client_by_id()| Note: client may not be fully\n    initialized. Use `on_init` to do any actions once the client has been\n    initialized."
    ],
    "seealso": []
  },
  "stop_client": {
    "annotations": [],
    "signature": "stop_client({client_id}, {force})",
    "parameters": [
      ["", "client_id"],
      ["", "force"]
    ],
    "parameters_doc": {
      "client_id": "client id or |vim.lsp.client| object, or list thereof",
      "force": "(boolean) (optional) shutdown forcefully"
    },
    "doc": [
      "Stops a client(s).",
      "You can also use the `stop()` function on a |vim.lsp.client| object. To\nstop all clients:",
      ">\n\n vim.lsp.stop_client(vim.lsp.get_active_clients())\n \n<",
      "By default asks the server to shutdown, unless stop was requested already\nfor this client, then force-shutdown is attempted."
    ],
    "return": [],
    "seealso": []
  },
  "stylize_markdown": {
    "annotations": [],
    "signature": "stylize_markdown({bufnr}, {contents}, {opts})",
    "parameters": [
      ["", "bufnr"],
      ["", "contents"],
      ["", "opts"]
    ],
    "parameters_doc": {
      "contents": "(table) of lines to show in window",
      "opts": "dictionary with optional fields\n                • height of floating window\n                • width of floating window\n                • wrap_at character to wrap at for computing height\n                • max_width maximal width of floating window\n                • max_height maximal height of floating window\n                • pad_top number of lines to pad contents at top\n                • pad_bottom number of lines to pad contents at bottom\n                • separator insert separator after code block"
    },
    "doc": [
      "Converts markdown into syntax highlighted regions by stripping the code\nblocks and converting them into highlighted code. This will by default\ninsert a blank line separator after those code block regions to improve\nreadability.",
      "This method configures the given buffer and returns the lines to set.",
      "If you want to open a popup with fancy markdown, use\n`open_floating_preview` instead"
    ],
    "return": ["width,height size of float"],
    "seealso": []
  },
  "symbols_to_items": {
    "annotations": [],
    "signature": "symbols_to_items({symbols}, {bufnr})",
    "parameters": [
      ["", "symbols"],
      ["", "bufnr"]
    ],
    "parameters_doc": { "symbols": "DocumentSymbol[] or SymbolInformation[]" },
    "doc": ["Converts symbols to quickfix list items."],
    "return": [],
    "seealso": []
  },
  "tagfunc": {
    "annotations": [],
    "signature": "tagfunc({...})",
    "parameters": [["", "..."]],
    "parameters_doc": {
      "pattern": "Pattern used to find a workspace symbol",
      "flags": "See |tag-function|"
    },
    "doc": [
      "Provides an interface between the built-in client and 'tagfunc'.",
      "When used with normal mode commands (e.g. |CTRL-]|) this will invoke the\n\"textDocument/definition\" LSP method to find the tag under the cursor.\nOtherwise, uses \"workspace/symbol\". If no results are returned from any\nLSP servers, falls back to using built-in tags."
    ],
    "return": ["A list of matching tags"],
    "seealso": []
  },
  "text_document_completion_list_to_complete_items": {
    "annotations": [],
    "signature": "text_document_completion_list_to_complete_items({result}, {prefix})",
    "parameters": [
      ["", "result"],
      ["", "prefix"]
    ],
    "parameters_doc": {
      "result": "The result of a `textDocument/completion` call, e.g. from\n              |vim.lsp.buf.completion()|, which may be one of\n              `CompletionItem[]`, `CompletionList` or `null`",
      "prefix": "(string) the prefix to filter the completion items"
    },
    "doc": [
      "Turns the result of a `textDocument/completion` request into\nvim-compatible |complete-items|."
    ],
    "return": ["{ matches = complete-items table, incomplete = bool }"],
    "seealso": ["|complete-items|"]
  },
  "trim_empty_lines": {
    "annotations": [],
    "signature": "trim_empty_lines({lines})",
    "parameters": [["", "lines"]],
    "parameters_doc": { "lines": "(table) list of lines to trim" },
    "doc": ["Removes empty lines from the beginning and end."],
    "return": ["(table) trimmed list of lines"],
    "seealso": []
  },
  "try_trim_markdown_code_blocks": {
    "annotations": [],
    "signature": "try_trim_markdown_code_blocks({lines})",
    "parameters": [["", "lines"]],
    "parameters_doc": { "lines": "(table) list of lines" },
    "doc": [
      "Accepts markdown lines and tries to reduce them to a filetype if they\ncomprise just a single code block.",
      "CAUTION: Modifies the input in-place!"
    ],
    "return": ["(string) filetype or 'markdown' if it was unchanged."],
    "seealso": []
  },
  "type_definition": {
    "annotations": [],
    "signature": "type_definition({options})",
    "parameters": [["", "options"]],
    "parameters_doc": {
      "options": "(table|nil) additional options\n               • reuse_win: (boolean) Jump to existing window if buffer is\n                 already open.\n               • on_list: (function) handler for list results. See\n                 |lsp-on-list-handler|"
    },
    "doc": ["Jumps to the definition of the type of the symbol under the cursor."],
    "return": [],
    "seealso": []
  },
  "with": {
    "annotations": [],
    "signature": "with({handler}, {override_config})",
    "parameters": [
      ["", "handler"],
      ["", "override_config"]
    ],
    "parameters_doc": {
      "handler": "(function) See |lsp-handler|",
      "override_config": "(table) Table containing the keys to override\n                       behavior of the {handler}"
    },
    "doc": ["Function to manage overriding defaults for LSP handlers."],
    "return": [],
    "seealso": []
  },
  "workspace_symbol": {
    "annotations": [],
    "signature": "workspace_symbol({query}, {options})",
    "parameters": [
      ["", "query"],
      ["", "options"]
    ],
    "parameters_doc": {
      "query": "(string, optional)",
      "options": "(table|nil) additional options\n               • on_list: (function) handler for list results. See\n                 |lsp-on-list-handler|"
    },
    "doc": [
      "Lists all symbols in the current workspace in the quickfix window.",
      "The list is filtered against {query}; if the argument is omitted from the\ncall, the user is prompted to enter a string on the command line. An empty\nstring means no filtering is done."
    ],
    "return": [],
    "seealso": []
  }
}
